alias ra='ranger --choosedir=$HOME/.local/share/ranger/dir; LASTDIR=`cat $HOME/.local/share/ranger/dir`; cd "$LASTDIR"'
alias gp='git pull --recurse-submodules'
alias gP='git push --recurse-submodules=check'
alias gs='git status'
alias gc='git commit -m'
alias db='dotbare'
alias gn='geeknote'
alias up='sudo apt-get update && sudo apt-get upgrade'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias x-www-browser='firefox.exe'
alias gnome-www-browser='firefox.exe'

export VISUAL=vim
export EDITOR="$VISUAL"
export PATH="$HOME/bin:$HOME/.local/bin:$PATH"

# disable scroll lock through ctrl-s
stty -ixon
export DISPLAY=localhost:0.0

# Show when running in a shell spawned by ranger
if [ -n "$RANGER_LEVEL" ]; then export PS1="[r]$PS1"; fi

eval "$(fasd --init posix-hook)"
eval "$(thefuck --alias)"

# Common fzf options
fzf_ops=(--preview "pygmentize {}" -0 -1)

######################## Opening files ########################
# Open file or change to its dir
f() {
  local show_hidden=1
  local exact=0
  local depth=2
  local query

  local header_tmpl="enter: open"
  header_tmpl+=", ctrl-d: to dir"
  header_tmpl+=", ctrl-e: exact [:exact:]"
  header_tmpl+=", ctrl-f: show hidden [:sh:]"
  header_tmpl+=", ctrl-x/ctrl-y: depth -/+ [:depth:]"

  while true; do
    if [ $exact = 1 ]; then
      local ep='--exact'
    else
      local ep=''
    fi

    if [ $show_hidden = 1 ]; then
      local pat=''
    else
      local pat='*/\.*'
    fi

    local header=$header_tmpl
    header=${header/:sh:/$show_hidden}
    header=${header/:exact:/$exact}
    header=${header/:depth:/$depth}

    local out=$(find . \
        -not \
        -path "$pat" \
        -mindepth 1 \
        -maxdepth $depth \
        -type f \
      2> /dev/null \
      | sed 's|^\./||' \
      | fzf \
        --preview "pygmentize {}" \
        --multi \
        $ep \
        --print-query \
        --query="$query" \
        --header="$header" \
        --expect=enter,ctrl-d,ctrl-e,ctrl-f,ctrl-x,ctrl-y)

    local query=$(echo "$out" | head -n 1)
    local   key=$(echo "$out" | sed  -n 2p)
    local files=$(echo "$out" | tail -n+3)

    case "$key" in
      enter)
        [[ -n "$files" ]] && ${EDITOR:-vim} $(echo "${files[@]}")
        return 0
        ;;
      ctrl-d)
        files=($files)
        cd "$(dirname "${files[1]}")"
        return 0
        ;;
      ctrl-e)
        let "exact = (exact + 1) % 2"
        ;;
      ctrl-f)
        let "show_hidden = (show_hidden + 1) % 2"
        ;;
      ctrl-x)
        let "depth--"
        ;;
      ctrl-y)
        let "depth++"
        ;;
      *)
        return 0
        ;;
    esac
  done
}

# Show grep results
ff() {
  if [ ! "$#" -gt 0 ]; then echo "Need a string to search for!"; return 1; fi
  hi="highlight -O ansi -l {} 2> /dev/null | rg --colors 'match:bg:yellow' --ignore-case --pretty --context 10 '$1' || rg --ignore-case --pretty --context 10 '$1' {}"
  file=$(rg --files-with-matches --no-messages "$1" | fzf -0 -1 --preview $hi)
  [[ -n "$file" ]] && vim -c "call search('$1', 'c')" "$file"
}

######################## Changing directory ########################
# cd to selected direct subdirectory
c() {
  local dir=$(find . -mindepth 1 -maxdepth ${1:-6} -type d -print 2> /dev/null | fzf +m)
  cd "$dir"
}

# cd sideways to sibling directory
cs() {
  local dir=$(find .. -mindepth 1 -maxdepth 1 -type d -print 2> /dev/null | fzf +m)
  cd "$dir"
}

# cd to selected parent directory
# go up n dirs or go to dir in pwd
u() {
    case $1 in
        *[!0-9]*)
            cd $(pwd | sed -r "s|(.*/$1[^/]*/).*|\1|")
            ;;
        '')
            local declare dirs=()
            get_parent_dirs() {
              if [[ -d "${1}" ]]; then dirs+=("$1"); else return; fi
              if [[ "${1}" == '/' ]]; then
                for _dir in "${dirs[@]}"; do echo $_dir; done
              else
                get_parent_dirs $(dirname "$1")
              fi
            }
            local dir="$(get_parent_dirs $(realpath "$PWD") | fzf --tac)"
            cd "$dir"
            ;;
        *)
            cd $(printf "%0.0s../" $(seq 1 $1));
            ;;
    esac
}

######################## Tmux ########################
# tm - create new tmux session, or switch to existing one. Works from within tmux too. (@bag-man)
# `tm` will allow you to select your tmux session via fzf.
# `tm irc` will attach to the irc session (if it exists), else it will create it.
tm() {
  [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
  if [ $1 ]; then
    tmux $change -t "$1" 2>/dev/null || (tmux new-session -d -s $1 && tmux $change -t "$1"); return
  fi
  session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0) &&  tmux $change -t "$session" || echo "No sessions found."
}

# fs [FUZZY PATTERN] - Select selected tmux session
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fs() {
  local session
  session=$(tmux list-sessions -F "#{session_name}" | \
    fzf --query="$1" --select-1 --exit-0) &&
  tmux switch-client -t "$session"
}

# ftpane - switch pane (@george-b)
ftpane() {
  local panes current_window current_pane target target_window target_pane
  panes=$(tmux list-panes -s -F '#I:#P - #{pane_current_path} #{pane_current_command}')
  current_pane=$(tmux display-message -p '#I:#P')
  current_window=$(tmux display-message -p '#I')

  target=$(echo "$panes" | grep -v "$current_pane" | fzf +m --reverse) || return

  target_window=$(echo $target | awk 'BEGIN{FS=":|-"} {print$1}')
  target_pane=$(echo $target | awk 'BEGIN{FS=":|-"} {print$2}' | cut -c 1)

  if [[ $current_window -eq $target_window ]]; then
    tmux select-pane -t ${target_window}.${target_pane}
  else
    tmux select-pane -t ${target_window}.${target_pane} &&
    tmux select-window -t $target_window
  fi
}

######################## Fasd ########################
# open best matched file using `fasd` if given argument,
# filter output of `fasd` using `fzf` else
v() {
  [ $# -gt 0 ] && fasd -f -e ${EDITOR} "$*" && return $?
  local file
  file="$(fasd -Rfl "$1" | fzf ${fzf_ops[@]} --no-sort +m)" && vi "${file}"
}

# open best matched dir using `fasd` if given argument,
# filter output of `fasd` using `fzf` else
z() {
  local dir
  if [ $# -gt 0 ]; then
    dir=$(fasd -de 'printf %s' $*)
  else
    dir="$(fasd -Rdl "$1" | fzf -1 -0 --no-sort)"
  fi
  cd "${dir}"
}

# cd into directory of file chosen via fasd
vz() {
  local file
  if [ $# -gt 0 ]; then
    file=$(fasd -f "$*")
  else
    file="$(fasd -Rfl "$1" | fzf -1 -0 --no-sort)"
  fi
  cd "$(dirname "$file")"
}

######################## Warp Directory ########################
# rename original wd
rename() {
    local ORIG_FUNC=$(declare -f $1)
    local NEWNAME_FUNC="$2${ORIG_FUNC#$1}"
    eval "$NEWNAME_FUNC"
}
